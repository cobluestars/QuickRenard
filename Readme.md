![QuickRenard Logo](https://github.com/cobluestars/QuickRenard/blob/main/public/QuickRenard.png?raw=true)

# ğŸ¦ŠquickrenardğŸ¦Š

<p> GraphQLì˜ ì›ë¦¬ë¥¼ ì¼ë¶€ ì°¨ìš©í•˜ì—¬,</p>
<p> Reactì˜ ìƒíƒœ(State)ì™€ í•¨ìˆ˜ë¥¼ ê´€ë¦¬í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ </p>
<br />

## ğŸ¦ŠQuick Renardë¥¼ ì œì‘í–ˆìŠµë‹ˆë‹¤.ğŸ¦Š

<p> Quick RenardëŠ” ì „ì—­ ìƒíƒœ ì €ì¥ì†Œë¥¼ í†µí•´ ìƒíƒœë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•˜ë©´ì„œ, </p>
<p> ìŠ¤í‚¤ë§ˆë¥¼ í†µí•œ ìœ íš¨ì„± ê²€ì‚¬ì™€ êµ¬ë… ê¸°ë°˜ì˜ ìƒíƒœ ë³€í™” ì•Œë¦¼ ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•˜ì—¬,</p> 
<p> Reactì˜ ìƒíƒœ ê´€ë¦¬ë¥¼ ê°„í¸í•˜ê³  íš¨ê³¼ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ë„ì™€ì£¼ëŠ” ë„êµ¬ì…ë‹ˆë‹¤. </p>
<br />

## ğŸ¦ŠVer 1.2.0ğŸ¦Š

## íƒ€ì… ê²€ì¦ ë¡œì§ ì¶”ê°€

<br />

### 1. Enum ê²€ì¦:

- enum í‚¤ë¥¼ í†µí•´ í—ˆìš©ëœ ë¬¸ìì—´ ì§‘í•©ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- í•´ë‹¹ ê°’ì´ enumì— ì •ì˜ëœ ë¬¸ìì—´ ì¤‘ í•˜ë‚˜ì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´, ìƒíƒœê°€ íŠ¹ì • ë¬¸ìì—´ ê°’ë“¤ ì¤‘ í•˜ë‚˜ë§Œ ê°€ì ¸ì•¼ í•  ê²½ìš° ì‚¬ìš©ë©ë‹ˆë‹¤.

### 2. ê°ì²´ ì†ì„± ê²€ì¦:

- properties í‚¤ë¥¼ í†µí•´ ê°ì²´ì˜ ê° ì†ì„±ì— ëŒ€í•œ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê° ì†ì„±ì˜ ìœ í˜•ì„ ê²€ì‚¬í•˜ì—¬ í•´ë‹¹ ì†ì„±ì´ ì˜¬ë°”ë¥¸ ìœ í˜•ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
- ê°ì²´ ë‚´ë¶€ì˜ ê° ì†ì„±ì´ ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¥´ëŠ”ì§€ ê²€ì‚¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

### 3. ë°°ì—´ í•­ëª© íƒ€ì… ê²€ì¦:

- ë°°ì—´ì˜ ëª¨ë“  í•­ëª©ì´ í•´ë‹¹ ìŠ¤í‚¤ë§ˆë¥¼ ì¤€ìˆ˜í•˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
- ë°°ì—´ ë‚´ë¶€ì˜ ê° í•­ëª©ì´ ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¥´ëŠ”ì§€ ê²€ì‚¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

<br />
<hr />
<br />

## ğŸ¦ŠVer 2.0.0ğŸ¦Š

## í•¨ìˆ˜ ì „ì—­ ê´€ë¦¬ì†Œ functionStore ì¶”ê°€

<br />

### 1. ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ëŒ€í‘œì ì¸ í•¨ìˆ˜ ìœ í˜•:

- ìˆœìˆ˜ í•¨ìˆ˜: ë™ì¼í•œ ì¸ìì— ëŒ€í•´ í•­ìƒ ë™ì¼í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³ , ì™¸ë¶€ ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
 
- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜: ë¬¸ìì—´ ì²˜ë¦¬, ë‚ ì§œ ê³„ì‚°, ìˆ«ì í¬ë§·íŒ… ë“± ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 
- í—¬í¼ í•¨ìˆ˜: ë°˜ë³µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë¡œì§ì„ ì¶”ìƒí™”í•œ í•¨ìˆ˜ì…ë‹ˆë‹¤ (ì˜ˆ: API ìš”ì²­).
 
### 2. ìœ„ì™€ ê°™ì€ í•¨ìˆ˜ë“¤ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìœ¼ë‚˜, ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤:
 
- ì‚¬ì´ë“œ ì´í™íŠ¸: í•¨ìˆ˜ê°€ ì™¸ë¶€ ì‹œìŠ¤í…œì˜ ìƒíƒœì— ì˜í–¥ì„ ì£¼ê±°ë‚˜ ê·¸ë¡œë¶€í„° ì˜í–¥ì„ ë°›ëŠ” ê²½ìš°,
(ì˜ˆì‹œ: ë°ì´í„°ë² ì´ìŠ¤ì— ì ‘ê·¼í•˜ê±°ë‚˜ ì™¸ë¶€ APIë¥¼ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜) ì˜ˆì¸¡í•˜ì§€ ëª»í•œ ê²°ê³¼ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 
- ìƒíƒœ ì˜ì¡´ì„±: í•¨ìˆ˜ê°€ ë‚´ë¶€ ìƒíƒœì— ì˜ì¡´í•˜ëŠ” ê²½ìš°, ê·¸ ìƒíƒœì˜ ë³€í™”ê°€ í•¨ìˆ˜ì˜ ê²°ê³¼ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 
- ìŠ¤ì½”í”„ì™€ í´ë¡œì €: í•¨ìˆ˜ê°€ íŠ¹ì • ìŠ¤ì½”í”„ì˜ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, ì´ëŸ¬í•œ ì˜ì¡´ì„±ì„ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

- ë™ì‹œì„± ì œì–´: ì—¬ëŸ¬ êµ¬ë…ìê°€ ë™ì¼í•œ í•¨ìˆ˜ì˜ ê²°ê³¼ë¥¼ êµ¬ë…í•  ë•Œ ë°œìƒí•˜ëŠ” ë™ì‹œì„± ì´ìŠˆë¥¼ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

- p.s: QuickRenard 2.1.0 ë²„ì „ì—ì„œëŠ” í•¨ìˆ˜ í˜¸ì¶œì— ëŒ€ì‘í•˜ëŠ” êµ¬ë…ê³¼ êµ¬ë… ì·¨ì†Œ ê³¼ì •ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ë¶€ì ìœ¼ë¡œ ìë™ìœ¼ë¡œ ê´€ë¦¬ë˜ë„ë¡ ê°œì„ í•˜ì˜€ìŠµë‹ˆë‹¤. ê°„ë‹¨íˆ ë§í•´, QuickRenardê°€ êµ¬ë…ê³¼ êµ¬ë… ì·¨ì†Œì˜ ì„¸ì„¸í•œ ê´€ë¦¬ë¥¼ ìë™í™”í•¨ìœ¼ë¡œì¨, ê°œë°œìëŠ” í•¨ìˆ˜ ë“±ë¡ ë° í˜¸ì¶œì— ì§‘ì¤‘í•  ìˆ˜ ìˆìœ¼ë©°, ë” ì•ˆì •ì ì´ê³  ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ìš´ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤. GraphQL ì»¨ì…‰ì§ˆì„ í•¨ìˆ˜ ì „ì—­ ê´€ë¦¬ì—ë„ ì ìš©í•´ë³´ë ¤ë‹¤ ë„ë¬´ì§€ ê°ë‹¹í•˜ì§€ ëª»í•´ì„œ ì´ëŸ° ê²°ì •ì„ ë‚´ë¦° ê±´ ì ˆëŒ€ë¡œ ì•„ë‹™ë‹ˆë‹¤.ğŸ’€

### functionStoreë¥¼ ì‚¬ìš©í•˜ë ¤ë©´, ì•„ë˜ì˜ !!! How to use !!! ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

<br />
<hr />
<br />

## ğŸ¦ŠVer 2.3.0ğŸ¦Š

## ìƒíƒœ ìºì‹± ë¡œì§ ì¶”ê°€:

<br />

### ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ìƒˆë¡œìš´ ê¸°ëŠ¥:
1. ìƒíƒœ ìºì‹±ì„ í†µí•´, ìì£¼ ì ‘ê·¼í•˜ëŠ” ìƒíƒœì— ëŒ€í•œ ì‹ ì†í•œ ê²€ìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ì‹œ, ì„±ëŠ¥ì´ ì „ë°˜ì ìœ¼ë¡œ ê°œì„ ë  ê²ƒì…ë‹ˆë‹¤.

2. ì´ì „ì— ìš”ì²­ëœ ìƒíƒœ ê°’ì„ ìºì‹œì— ì €ì¥í•©ë‹ˆë‹¤. ê°™ì€ ìƒíƒœë¥¼ ë‹¤ì‹œ ìš”ì²­í•  ë•Œ ì‹ ì†í•œ ì‘ë‹µì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë³µì¡í•œ ê³„ì‚° í˜¹ì€ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ê°€ í•„ìš”í•œ ìƒíƒœì˜ ê²½ìš°, íŠ¹íˆ ì´ ê¸°ëŠ¥ì€ ìœ ìš©í•  ê²ƒì…ë‹ˆë‹¤.

3. ë„¤íŠ¸ì›Œí¬ ì§€ì—°, ì„œë²„ ê³¼ë¶€í•˜ë¥¼ ì˜ˆë°©í•˜ëŠ” ë°ì— íš¨ê³¼ì ì…ë‹ˆë‹¤. ì›ê²© ë°ì´í„°ë¥¼ ìƒíƒœë¡œ ê´€ë¦¬í•˜ëŠ” ê²½ìš°, ìºì‹±ì€ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ìˆ˜ë¥¼ ì¤„ì„ìœ¼ë¡œì¨, ë°ì´í„° ì „ì†¡ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ìºì‹± ê´€ë ¨ ì£¼ì˜ì‚¬í•­:
- ìºì‹œëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ìœ„í•´ 15ë¶„ ë’¤ì— ë§Œë£Œë©ë‹ˆë‹¤.

### ì—…ë°ì´íŠ¸ë¥¼ í†µí•´ QuickRenardëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„±ëŠ¥ì„ ê°œì„ í•˜ê³ , ë³´ë‹¤ íš¨ìœ¨ì ìœ¼ë¡œ ìƒíƒœ ê´€ë¦¬ë¥¼ í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•©ë‹ˆë‹¤. Ver 2.3.0 ì—…ë°ì´íŠ¸ëŠ” íŠ¹íˆ ëŒ€ê·œëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜ ë° ë°ì´í„° ì§‘ì•½ì  ì‘ì—…ì— ì¤‘ì ì„ ë‘ê³  ì§„í–‰í–ˆìŠµë‹ˆë‹¤.

<br />
<hr />
<br />

### 1. ì •ì˜ ë° ì„¤ê³„
1. ì¿¼ë¦¬ ê¸°ë°˜ì˜ ìƒíƒœ ì •ì˜: ê° ìƒíƒœë¥¼ GraphQL ìŠ¤í‚¤ë§ˆì²˜ëŸ¼ ì •ì˜í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ìƒíƒœì˜ íƒ€ì…, ì´ˆê¸° ê°’, ì˜ì¡´ì„± ë“±ì„ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
2. ì¿¼ë¦¬ ë° ë³€ì´ ì‘ì„±: ì‚¬ìš©ìê°€ ìƒíƒœë¥¼ ì¡°íšŒí•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ ì¿¼ë¦¬ì™€ ë³€ì´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### 2. ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„
1. ìƒíƒœ ì €ì¥ì†Œ: ëª¨ë“  ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ì¤‘ì•™ ì €ì¥ì†Œë¥¼ ë§Œë“­ë‹ˆë‹¤.
2. ì¿¼ë¦¬ í•´ì„ê¸°: ì£¼ì–´ì§„ ì¿¼ë¦¬ë¥¼ í•´ì„í•˜ê³  í•´ë‹¹í•˜ëŠ” ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
3. ë³€ì´(Mutation) ì²˜ë¦¬ê¸°: ì£¼ì–´ì§„ ë³€ì´(Mutation)ë¥¼ í•´ì„í•˜ê³  ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
4. êµ¬ë…(subscription) ë©”ì»¤ë‹ˆì¦˜: íŠ¹ì • ìƒíƒœì˜ ë³€ì´ë¥¼ êµ¬ë…(subscription)í•˜ê³ , ë³€ì´ê°€ ê°ì§€ë˜ë©´ ì½œë°±ì„ ì‹¤í–‰í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### 3. React Hooks
1. useStateQuery: ì£¼ì–´ì§„ ì¿¼ë¦¬ì— í•´ë‹¹í•˜ëŠ” ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.
2. useStateMutation: ì£¼ì–´ì§„ ë³€ì´ë¥¼ ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜ì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.
3. useStateSubscription: ì£¼ì–´ì§„ ìƒíƒœì˜ ë³€í™”ë¥¼ êµ¬ë…í•˜ê³ , ë³€í™”ê°€ ê°ì§€ë˜ë©´ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¦¬ë Œë”ë§í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.


- ì‚¬ìš©ìëŠ” ì¿¼ë¦¬ì™€ ë³€ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒíƒœì— ì‰½ê²Œ ì ‘ê·¼í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìˆìœ¼ë©°,
- í•„ìš”í•œ ìƒíƒœì˜ ë³€í™”ë§Œì„ êµ¬ë…í•˜ì—¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¦¬ë Œë”ë§í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

<br />

### 1. ìƒíƒœ ì €ì¥ì†Œ (stateStore):

- Quick Renard ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ì „ì—­ì ìœ¼ë¡œ ê´€ë¦¬ë˜ëŠ” stateStoreë¼ëŠ” ì¤‘ì•™ ì €ì¥ì†Œë¥¼ í†µí•´ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤. ì´ ì €ì¥ì†Œì—ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ìƒíƒœê°€ ì €ì¥ë˜ë©°, 
ì¿¼ë¦¬ ê¸°ë°˜ì˜ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • ìƒíƒœë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 2. ìƒíƒœ ìŠ¤í‚¤ë§ˆ (StateSchema):

- ìƒíƒœì˜ êµ¬ì¡°ì™€ ê¸°ëŒ€ë˜ëŠ” íƒ€ì…, ê¸°ë³¸ê°’ ë“±ì„ ì •ì˜í•˜ê¸° ìœ„í•´ ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ìƒíƒœì˜ ì´ˆê¸° ì„¤ì •ì„ ì‰½ê²Œ í•  ìˆ˜ ìˆìœ¼ë©°, ìƒíƒœ ë³€ê²½ ì‹œ ìœ íš¨ì„± ê²€ì‚¬ì˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### 3. ìƒíƒœ ë³€ì´ (setStateMutation):

- ì´ í•¨ìˆ˜ë¥¼ í†µí•´ ìƒíƒœë¥¼ ìˆ˜ì •í•˜ê²Œ ë©ë‹ˆë‹¤. í•¨ìˆ˜ ë‚´ë¶€ì—ì„œëŠ” ìŠ¤í‚¤ë§ˆë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒíƒœì˜ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìœ¼ë©°, í•´ë‹¹ ìƒíƒœì— ë³€í™”ê°€ ìˆì„ ê²½ìš°, ê·¸ ìƒíƒœë¥¼ êµ¬ë…í•˜ê³  ìˆëŠ” ëª¨ë“  êµ¬ë…ìë“¤ì—ê²Œ ì•Œë¦¼ì„ ë³´ëƒ…ë‹ˆë‹¤.

### 4. ìƒíƒœ êµ¬ë… (subscribeStateChange):

- íŠ¹ì • ìƒíƒœì˜ ë³€í™”ë¥¼ ê´€ì°°í•˜ê³ ì í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ëŠ” ì´ í•¨ìˆ˜ë¥¼ í†µí•´ í•´ë‹¹ ìƒíƒœì˜ ë³€í™”ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤. ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ êµ¬ë…í•˜ê³  ìˆëŠ” ì»´í¬ë„ŒíŠ¸ëŠ” ì½œë°± í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê²Œ ë©ë‹ˆë‹¤. 
ì´ë¥¼ í†µí•´ ìƒíƒœ ë³€í™”ì— ë”°ë¥¸ ë¦¬ë Œë”ë§ì´ë‚˜ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ìš”ì•½:

1. ìƒíƒœë¥¼ ì¿¼ë¦¬í™”í•˜ì—¬ statestoreì— ì €ì¥í•´ì„œ ì „ì—­ìœ¼ë¡œ ê´€ë¦¬í•˜ê³ ,
2. ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•´ ìƒíƒœì˜ êµ¬ì¡°ì™€ íƒ€ì…ì„ ì •ì˜í•˜ê³ ,
3. setStateMutationê°™ì€ í•¨ìˆ˜ì—ì„œ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ê³  ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•˜ë©°, 
4. setStateSubscriptionì„ ì´ìš©í•´ ìƒíƒœë¥¼ ì‚¬ìš©í•˜ê¸¸ ì›í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•´ì„œ ì‚¬ìš©

<br />
<br />

# â—â—â— How to use â—â—â—

<br />

# ğŸ¦Š quickrenard ğŸ¦Š
## : A Simple State Management in React

QuickRenard(quickrenard) is a lightweight state management solution for React applications. By providing clear paths for data querying, mutation, and subscriptions, QuickRenard streamlines the state-sharing process between components, even if they aren't directly related in the component tree.

<br />
<br />

## ğŸ¦ŠVer 2.3.0ğŸ¦Š

### Added State Caching Logic:

1. New Features for Performance Optimization: State caching enables swift retrieval of frequently accessed states, leading to overall performance improvements when using the library.

2. Previously requested state values are stored in the cache. This allows for quick responses when the same state is requested again. This feature is especially beneficial for states that require complex calculations or database queries.

3. It is effective in preventing network delays and server overloads. When managing remote data as state, caching can reduce the number of network requests, making data transfer more efficient.

### Cautions Related to Caching:
- To manage memory, the cache expires after 15 minutes.

### Through this update, QuickRenard aims to enhance application performance and enable more efficient state management. The Ver 2.3.0 update has been focused particularly on large-scale applications and data-intensive tasks.

<br />
<br />

## ğŸ¦ŠVersion 2.0.0ğŸ¦Š

### Global function management feature 'functionStore' added

### 1. List of representative function types that can be managed:

- Pure Functions: Functions that always return the same result for the same arguments without changing external state.

- Utility Functions: Functions that provide reusable functionalities such as string processing, date calculations, number formatting, etc.

- Helper Functions: Functions that abstract commonly used logic throughout the application (e.g., API requests).

### 2. While this function store can effectively manage the above types of functions, the following precautions are necessary:

- Side Effects: Functions that affect or are affected by the state of external systems,
 (such as accessing a database or calling external APIs) can lead to unpredictable results.

- State Dependency: Functions that depend on internal state may have results that are affected by changes to that state.

- Scope and Closures: Functions that use variables from a specific scope need to have these dependencies managed.

- Concurrency Control: Issues of concurrency that arise when multiple subscribers subscribe to the results of the same function must be managed.

<br />
<br />

## ğŸ¦ŠVer 1.2.0ğŸ¦Š

### Added type validation logic.

1. Enum validation:

- You can define an allowed set of string values through the enum key.
- It checks if the value is one of the strings defined in the enum.
- This is used when the state should only have one of specific string values.

2. Object property validation:

- You can define a schema for each property of the object using the properties key.
- It verifies the type of each property to ensure it's of the correct type.
- It's used to check if each property within the object adheres to the defined schema.

3. Array item type validation:

- It checks if all items in the array adhere to the specified schema.
- This is used to verify if each item inside the array follows the defined schema.

<br />
<hr />
<br />

## Setup and Initialization

To start using quickrenard, you first need to define a schema for your state and then initialize the store.

### 1. Define State Schema:

Your state is structured based on a schema. This schema outlines the shape, type, and default values of your state properties.

```javascript
// stateSchema.js
export const stateSchema = {
    'childData.data': {
        type: 'string',
        defaultValue: 'initialValue'
    }
};
```

### 2. Initialize Store:
Once you have your schema in place, initialize the state store with it. This sets up the initial state for your application.

```javascript
// stateStore.js
import { initializeStore } from 'quickrenard';
import { stateSchema } from './stateSchema';

initializeStore(stateSchema);
```

### 3. Using quickrenard in Components

#### Querying State:
To access a state property within a component, use the useStateQuery hook. This hook queries and retrieves the value of the specified state property.

```javascript
const data = useStateQuery("childData.data");
```

#### Mutating State:
For updating the state, use the useStateMutation hook. This hook provides a function to update a specific state property and also returns the current value of that property.


```javascript
const [updateChildData, data] = useStateMutation("childData.data");
```

#### Subscribing to State Changes:
If you want a component to react to changes in the state, use the useStateSubscription hook. It allows you to provide a callback function that will be called whenever the specified state property changes.

```javascript
useStateSubscription("childData.data", handleDataChange);
```

## Example: Sharing State Between Distant Components
Consider a scenario where you have two components, Child and Cousin, that aren't directly related in the component tree. Yet, you want to share state data between them using QuickRenard.

<br />

### Child Component:
This component mutates the data.

```javascript
// Child.js
import React from 'react';
import { useStateMutation } from 'quickrenard';

function Child() {
  const [updateChildData, data] = useStateMutation("childData.data");

  const handleUpdateData = () => {
    updateChildData("Updated Data from Child");
    console.log("Data updated!");
  };

  return (
    <div>
      <h3>Child Component</h3>
      <p>Data: {data}</p>
      <button onClick={handleUpdateData}>Update Data</button>
    </div>
  );
}
```

### Cousin Component:
This component queries the data and subscribes to its changes.

```javascript
// Cousin.js
import React from 'react';
import { useStateQuery, useStateSubscription } from 'quickrenard';

function Cousin() {
  const data = useStateQuery("childData.data");

  const handleDataChange = () => {
    console.log("Child data has changed!");
  };

  useStateSubscription("childData.data", handleDataChange);

  return (
    <div>
      <h3>Cousin Component</h3>
      <p>Data from Child: {data}</p>
    </div>
  );
}
```

With quickrenard, even if Child and Cousin aren't directly related, the state update in Child will trigger a subscription callback in Cousin, allowing seamless state sharing across different parts of your React application.

<br />
<hr />
<br />

# ğŸ¦Š QuickRenard ğŸ¦Š 
## Ver 2.1.0: State & Function Management in React

QuickRenard is your go-to library for streamlined global state and function management within React applications. The latest update, version 2.0.0, introduces a game-changing feature: the functionStore. This new capability complements the existing state management tools, enabling developers to create, invoke, and listen to global functions throughout their component hierarchy. It simplifies the management of cross-component logic and reduces the complexity of prop drilling.

<br />
<hr />
<br />

## ğŸ¦Š What's New in Version 2.1.0 ğŸ¦Š

- FunctionStore: A global registry for functions to be accessed and executed across components.
- Function Invocation: Call any registered global function from anywhere within your app.
- Function Subscriptions: Set up listeners for function calls to manage side effects or perform cleanup tasks.
- Enhanced Code Maintainability: Abstract common logic into globally accessible functions, leading to cleaner and more maintainable codebases.

### ğŸ¦Š Quick Start with QuickRenard's Function Store ğŸ¦Š

- Step 1: Import function management APIs from QuickRenard.

```javascript
import { registerFunction, callFunction } from 'quickrenard';
```

- Step 2: Register functions that can be globally accessed.

```javascript
registerFunction('logActivity', message => console.log(`Activity: ${message}`));
```

- Step 3: Invoke registered functions from any component, passing required arguments.

```javascript
callFunction('logActivity', 'User logged in');
```

- Step 4: Set up subscriptions if you want components to react to function invocations.

```javascript
// This part of the API is now internally managed by QuickRenard, no need for manual subscription.
```

- Step 5: Unsubscribe from functions to clean up listeners.

```javascript
// This is also managed internally when components unmount or when you stop using the function in QuickRenard.
```

- QuickRenard version 2.0.0 makes your components more independent and your application more scalable by providing a central hub for state and function management.

<br />

## ğŸ¦ŠPractical Examples with QuickRenardğŸ¦Š

### Example: Inter-Component Communication with State and Functions

- Let's look at how components like Child and Cousin can interact through shared state and functions without direct lineage or prop drilling.

### 1. Child Component:

- Here, Child updates shared state and provides a function for others to call.

```javascript
// Child.js
import React from 'react';
import { useStateMutation, registerFunction } from 'quickrenard';

function Child() {
  const [setChildData, childData] = useStateMutation("childData.data");

  const handleUpdateData = () => {
    setChildData("Updated Data from Child");
    console.log("Child data updated.");
  };  

  // Register a function for others to invoke
  registerFunction('childFunction', message => {
    console.log("Child received a message:", message);
    return "Message processed by Child";
  });

  return (
    <div>
      <h3>Child Component</h3>
      <p>Data: {childData}</p>
      <button onClick={handleUpdateData}>Update Data</button>
    </div>
  );
}

export default Child;
```

### 2. Cousin Component:

- Cousin listens for state changes and can invoke Child's function.

```javascript
// Cousin.js
import React, { useEffect } from 'react';
import { useStateQuery, useStateSubscription, callFunction } from 'quickrenard';

function Cousin() {
  const childData = useStateQuery("childData.data");

  useStateSubscription('childData.data', () => {
    console.log("Child data has changed!");
    // Invoke the function registered by Child
    try {
      const response = callFunction('childFunction', 'Hello World! - from Cousin');
      console.log('Response from Child:', response);
    } catch (error) {
      console.error(error.message);
    }
  });

  useEffect(() => {
    // This will run once when the component mounts
    console.log('Cousin mounted. Initial data:', childData);
  }, []); // Empty dependency array to mimic componentDidMount behavior

  return (
    <div>
      <h3>Cousin Component</h3>
      <p>Data from Child: {childData}</p>
    </div>
  );
}

export default Cousin;
```

The functionStore feature in QuickRenard version 2.1.0 offers an elegant solution to managing state and functions, making it a holistic choice for developers seeking efficiency and maintainability in their React applications. Adjust your component implementations as necessary to align with these examples and the unique details of your project. This documentation is designed to provide a conceptual understanding of QuickRenard's enhanced functionality.