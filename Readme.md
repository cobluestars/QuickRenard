![QuickRenard Logo](https://github.com/cobluestars/QuickRenard/blob/main/public/QuickRenard.png?raw=true)

# ğŸ¦ŠquickrenardğŸ¦Š

<p> GraphQLì˜ ì›ë¦¬ë¥¼ ì¼ë¶€ ì°¨ìš©í•˜ì—¬ </p>
<p> Reactì˜ ìƒíƒœ(State)ì™€ í•¨ìˆ˜ë¥¼ ê´€ë¦¬í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ </p>
<br />

## ğŸ¦ŠQuick Renardë¥¼ ì œì‘í–ˆìŠµë‹ˆë‹¤.ğŸ¦Š

<p> Quick RenardëŠ” ì „ì—­ ìƒíƒœ ì €ì¥ì†Œë¥¼ í†µí•´ ìƒíƒœë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•˜ë©´ì„œ, </p>
<p> ìŠ¤í‚¤ë§ˆë¥¼ í†µí•œ ìœ íš¨ì„± ê²€ì‚¬ì™€ êµ¬ë… ê¸°ë°˜ì˜ ìƒíƒœ ë³€í™” ì•Œë¦¼ ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•˜ì—¬, </p> 
<p> React ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ìƒíƒœ ê´€ë¦¬ë¥¼ ê°„í¸í•˜ê³  íš¨ê³¼ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ë„ì™€ì£¼ëŠ” ë„êµ¬ì…ë‹ˆë‹¤. </p>
<br />

## ğŸ¦ŠVer 1.2.0ğŸ¦Š

<label> íƒ€ì… ê²€ì¦ ë¡œì§ ì¶”ê°€ </label>

<br />

1. Enum ê²€ì¦:

- enum í‚¤ë¥¼ í†µí•´ í—ˆìš©ëœ ë¬¸ìì—´ ì§‘í•©ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- í•´ë‹¹ ê°’ì´ enumì— ì •ì˜ëœ ë¬¸ìì—´ ì¤‘ í•˜ë‚˜ì¸ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´, ìƒíƒœê°€ íŠ¹ì • ë¬¸ìì—´ ê°’ë“¤ ì¤‘ í•˜ë‚˜ë§Œ ê°€ì ¸ì•¼ í•  ê²½ìš° ì‚¬ìš©ë©ë‹ˆë‹¤.

2. ê°ì²´ ì†ì„± ê²€ì¦:

- properties í‚¤ë¥¼ í†µí•´ ê°ì²´ì˜ ê° ì†ì„±ì— ëŒ€í•œ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê° ì†ì„±ì˜ ìœ í˜•ì„ ê²€ì‚¬í•˜ì—¬ í•´ë‹¹ ì†ì„±ì´ ì˜¬ë°”ë¥¸ ìœ í˜•ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
- ê°ì²´ ë‚´ë¶€ì˜ ê° ì†ì„±ì´ ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¥´ëŠ”ì§€ ê²€ì‚¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

3. ë°°ì—´ í•­ëª© íƒ€ì… ê²€ì¦:

- ë°°ì—´ì˜ ëª¨ë“  í•­ëª©ì´ í•´ë‹¹ ìŠ¤í‚¤ë§ˆë¥¼ ì¤€ìˆ˜í•˜ëŠ”ì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
- ë°°ì—´ ë‚´ë¶€ì˜ ê° í•­ëª©ì´ ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¥´ëŠ”ì§€ ê²€ì‚¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

<br />
<hr />
<br />

## ğŸ¦ŠVer 2.0.0ğŸ¦Š

<label> í•¨ìˆ˜ ì „ì—­ ê´€ë¦¬ ê¸°ëŠ¥ functionStore ì¶”ê°€ </label>

### 1. ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ëŒ€í‘œì ì¸ í•¨ìˆ˜ ìœ í˜• ëª©ë¡:

 - ìˆœìˆ˜ í•¨ìˆ˜: ë™ì¼í•œ ì¸ìì— ëŒ€í•´ í•­ìƒ ë™ì¼í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³ , ì™¸ë¶€ ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
 
 - ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜: ë¬¸ìì—´ ì²˜ë¦¬, ë‚ ì§œ ê³„ì‚°, ìˆ«ì í¬ë§·íŒ… ë“± ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 
 - í—¬í¼ í•¨ìˆ˜: ë°˜ë³µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë¡œì§ì„ ì¶”ìƒí™”í•œ í•¨ìˆ˜ì…ë‹ˆë‹¤ (ì˜ˆ: API ìš”ì²­).
 
### 2. ì´ í•¨ìˆ˜ ì €ì¥ì†ŒëŠ” ìœ„ì˜ ìœ í˜•ì˜ í•¨ìˆ˜ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìœ¼ë‚˜, ë‹¤ìŒì˜ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤:
 
 - ì‚¬ì´ë“œ ì´í™íŠ¸: í•¨ìˆ˜ê°€ ì™¸ë¶€ ì‹œìŠ¤í…œì˜ ìƒíƒœì— ì˜í–¥ì„ ì£¼ê±°ë‚˜ ê·¸ë¡œë¶€í„° ì˜í–¥ì„ ë°›ëŠ” ê²½ìš°,
  (ì˜ˆì‹œ: ë°ì´í„°ë² ì´ìŠ¤ì— ì ‘ê·¼í•˜ê±°ë‚˜ ì™¸ë¶€ APIë¥¼ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜) ì˜ˆì¸¡í•˜ì§€ ëª»í•œ ê²°ê³¼ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 
 - ìƒíƒœ ì˜ì¡´ì„±: í•¨ìˆ˜ê°€ ë‚´ë¶€ ìƒíƒœì— ì˜ì¡´í•˜ëŠ” ê²½ìš°, ê·¸ ìƒíƒœì˜ ë³€í™”ê°€ í•¨ìˆ˜ì˜ ê²°ê³¼ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 
 - ìŠ¤ì½”í”„ì™€ í´ë¡œì €: í•¨ìˆ˜ê°€ íŠ¹ì • ìŠ¤ì½”í”„ì˜ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, ì´ëŸ¬í•œ ì˜ì¡´ì„±ì„ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

 - ë™ì‹œì„± ì œì–´: ì—¬ëŸ¬ êµ¬ë…ìê°€ ë™ì¼í•œ í•¨ìˆ˜ì˜ ê²°ê³¼ë¥¼ êµ¬ë…í•  ë•Œ ë°œìƒí•˜ëŠ” ë™ì‹œì„± ì´ìŠˆë¥¼ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

### functionStoreë¥¼ ì‚¬ìš©í•˜ë ¤ë©´, ì•„ë˜ì— ìˆëŠ” !!! How to use !!! ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

<br />
<hr />
<br />

### 1. ì •ì˜ ë° ì„¤ê³„
ì¿¼ë¦¬ ê¸°ë°˜ì˜ ìƒíƒœ ì •ì˜: ê° ìƒíƒœë¥¼ GraphQL ìŠ¤í‚¤ë§ˆì²˜ëŸ¼ ì •ì˜í•©ë‹ˆë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, ìƒíƒœì˜ íƒ€ì…, ì´ˆê¸° ê°’, ì˜ì¡´ì„± ë“±ì„ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.

ì¿¼ë¦¬ ë° ë³€ì´ ì‘ì„±: ì‚¬ìš©ìê°€ ìƒíƒœë¥¼ ì¡°íšŒí•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ ì¿¼ë¦¬ì™€ ë³€ì´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### 2. ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„
1. ìƒíƒœ ì €ì¥ì†Œ: ëª¨ë“  ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ì¤‘ì•™ ì €ì¥ì†Œë¥¼ ë§Œë“­ë‹ˆë‹¤.
2. ì¿¼ë¦¬ í•´ì„ê¸°: ì£¼ì–´ì§„ ì¿¼ë¦¬ë¥¼ í•´ì„í•˜ê³  í•´ë‹¹í•˜ëŠ” ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
3. ë³€ì´(Mutation) ì²˜ë¦¬ê¸°: ì£¼ì–´ì§„ ë³€ì´(Mutation)ë¥¼ í•´ì„í•˜ê³  ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
4. êµ¬ë…(subscription) ë©”ì»¤ë‹ˆì¦˜: íŠ¹ì • ìƒíƒœì˜ ë³€ì´ë¥¼ êµ¬ë…(subscription)í•˜ê³ , ë³€ì´ê°€ ê°ì§€ë˜ë©´ ì½œë°±ì„ ì‹¤í–‰í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### 3. React Hooks
1. useStateQuery: ì£¼ì–´ì§„ ì¿¼ë¦¬ì— í•´ë‹¹í•˜ëŠ” ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.
2. useStateMutation: ì£¼ì–´ì§„ ë³€ì´ë¥¼ ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜ì™€ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.
3. useStateSubscription: ì£¼ì–´ì§„ ìƒíƒœì˜ ë³€í™”ë¥¼ êµ¬ë…í•˜ê³ , ë³€í™”ê°€ ê°ì§€ë˜ë©´ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¦¬ë Œë”ë§í•˜ëŠ” Hookì„ ì œê³µí•©ë‹ˆë‹¤.


<p>ì‚¬ìš©ìëŠ” ì¿¼ë¦¬ì™€ ë³€ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒíƒœì— ì‰½ê²Œ ì ‘ê·¼í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìˆìœ¼ë©°,</p>
<p>í•„ìš”í•œ ìƒíƒœì˜ ë³€í™”ë§Œì„ êµ¬ë…í•˜ì—¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¦¬ë Œë”ë§í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.</p>

<br />

### 1. ìƒíƒœ ì €ì¥ì†Œ (stateStore):

Quick Renard ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œëŠ” ì „ì—­ì ìœ¼ë¡œ ê´€ë¦¬ë˜ëŠ” stateStoreë¼ëŠ” ì¤‘ì•™ ì €ì¥ì†Œë¥¼ í†µí•´ ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤. 

ì´ ì €ì¥ì†Œì—ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ìƒíƒœê°€ ì €ì¥ë˜ë©°, 
ì¿¼ë¦¬ ê¸°ë°˜ì˜ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • ìƒíƒœë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 2. ìƒíƒœ ìŠ¤í‚¤ë§ˆ (StateSchema):

ìƒíƒœì˜ êµ¬ì¡°ì™€ ê¸°ëŒ€ë˜ëŠ” íƒ€ì…, ê¸°ë³¸ê°’ ë“±ì„ ì •ì˜í•˜ê¸° ìœ„í•´ ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
ì´ë¥¼ í†µí•´ ìƒíƒœì˜ ì´ˆê¸° ì„¤ì •ì„ ì‰½ê²Œ í•  ìˆ˜ ìˆìœ¼ë©°, ìƒíƒœ ë³€ê²½ ì‹œ ìœ íš¨ì„± ê²€ì‚¬ì˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### 3. ìƒíƒœ ë³€ì´ (setStateMutation):

ì´ í•¨ìˆ˜ë¥¼ í†µí•´ ìƒíƒœë¥¼ ìˆ˜ì •í•˜ê²Œ ë©ë‹ˆë‹¤.
í•¨ìˆ˜ ë‚´ë¶€ì—ì„œëŠ” ìŠ¤í‚¤ë§ˆë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒíƒœì˜ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìœ¼ë©°,
í•´ë‹¹ ìƒíƒœì— ë³€í™”ê°€ ìˆì„ ê²½ìš°, ê·¸ ìƒíƒœë¥¼ êµ¬ë…í•˜ê³  ìˆëŠ” ëª¨ë“  êµ¬ë…ìë“¤ì—ê²Œ ì•Œë¦¼ì„ ë³´ëƒ…ë‹ˆë‹¤.

### 4. ìƒíƒœ êµ¬ë… (subscribeStateChange):

íŠ¹ì • ìƒíƒœì˜ ë³€í™”ë¥¼ ê´€ì°°í•˜ê³ ì í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ëŠ” ì´ í•¨ìˆ˜ë¥¼ í†µí•´ í•´ë‹¹ ìƒíƒœì˜ ë³€í™”ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤. 
ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ êµ¬ë…í•˜ê³  ìˆëŠ” ì»´í¬ë„ŒíŠ¸ëŠ” ì½œë°± í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê²Œ ë©ë‹ˆë‹¤. 
ì´ë¥¼ í†µí•´ ìƒíƒœ ë³€í™”ì— ë”°ë¥¸ ë¦¬ë Œë”ë§ì´ë‚˜ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


### ìš”ì•½:
1. ìƒíƒœë¥¼ ì¿¼ë¦¬í™”í•˜ì—¬ statestoreì— ì €ì¥í•´ì„œ ì „ì—­ìœ¼ë¡œ ê´€ë¦¬í•˜ê³ ,
2. ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•´ ìƒíƒœì˜ êµ¬ì¡°ì™€ íƒ€ì…ì„ ì •ì˜í•˜ê³ ,
3. setStateMutationê°™ì€ í•¨ìˆ˜ì—ì„œ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•˜ê³  ì´ˆê¸° ìƒíƒœë¥¼ ì„¤ì •í•˜ë©°, 
4. setStateSubscriptionì„ ì´ìš©í•´ ìƒíƒœë¥¼ ì‚¬ìš©í•˜ê¸¸ ì›í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì—ì„œ êµ¬ë…í•´ì„œ ì‚¬ìš©

<br />
<br />

# â—â—â— How to use â—â—â—

# ğŸ¦Š quickrenard ğŸ¦Š: A Simple State Management in React

QuickRenard(quickrenard) is a lightweight state management solution for React applications. By providing clear paths for data querying, mutation, and subscriptions, QuickRenard streamlines the state-sharing process between components, even if they aren't directly related in the component tree.

<br />
<hr />
<br />

## ğŸ¦ŠVersion 2.0.0ğŸ¦Š

<label> Global function management feature 'functionStore' added </label>

### 1. List of representative function types that can be managed:

- Pure Functions: Functions that always return the same result for the same arguments without changing external state.

- Utility Functions: Functions that provide reusable functionalities such as string processing, date calculations, number formatting, etc.

- Helper Functions: Functions that abstract commonly used logic throughout the application (e.g., API requests).

### 2. While this function store can effectively manage the above types of functions, the following precautions are necessary:

- Side Effects: Functions that affect or are affected by the state of external systems,
 (such as accessing a database or calling external APIs) can lead to unpredictable results.

- State Dependency: Functions that depend on internal state may have results that are affected by changes to that state.

- Scope and Closures: Functions that use variables from a specific scope need to have these dependencies managed.

- Concurrency Control: Issues of concurrency that arise when multiple subscribers subscribe to the results of the same function must be managed.

<br />
<hr />
<br />

## ğŸ¦ŠVer 1.2.0ğŸ¦Š

Added type validation logic.

1. Enum validation:

- You can define an allowed set of string values through the enum key.
- It checks if the value is one of the strings defined in the enum.
- This is used when the state should only have one of specific string values.

2. Object property validation:

- You can define a schema for each property of the object using the properties key.
- It verifies the type of each property to ensure it's of the correct type.
- It's used to check if each property within the object adheres to the defined schema.

3. Array item type validation:

- It checks if all items in the array adhere to the specified schema.
- This is used to verify if each item inside the array follows the defined schema.

<br />
<hr />
<br />

## Setup and Initialization

To start using quickrenard, you first need to define a schema for your state and then initialize the store.

### 1. Define State Schema:

Your state is structured based on a schema. This schema outlines the shape, type, and default values of your state properties.

```javascript
// stateSchema.js
export const stateSchema = {
    'childData.data': {
        type: 'string',
        defaultValue: 'initialValue'
    }
};
```

### 2. Initialize Store:
Once you have your schema in place, initialize the state store with it. This sets up the initial state for your application.

```javascript
// stateStore.js
import { initializeStore } from 'quickrenard';
import { stateSchema } from './stateSchema';

initializeStore(stateSchema);
```

### 3. Using quickrenard in Components

#### Querying State:
To access a state property within a component, use the useStateQuery hook. This hook queries and retrieves the value of the specified state property.

```javascript
const data = useStateQuery("childData.data");
```

#### Mutating State:
For updating the state, use the useStateMutation hook. This hook provides a function to update a specific state property and also returns the current value of that property.


```javascript
const [updateChildData, data] = useStateMutation("childData.data");
```

#### Subscribing to State Changes:
If you want a component to react to changes in the state, use the useStateSubscription hook. It allows you to provide a callback function that will be called whenever the specified state property changes.

```javascript
useStateSubscription("childData.data", handleDataChange);
```

## Example: Sharing State Between Distant Components

Consider a scenario where you have two components, Child and Cousin, that aren't directly related in the component tree. Yet, you want to share state data between them using QuickRenard.

### Child Component:
This component mutates the data.

```javascript
// Child.js
import React from 'react';
import { useStateMutation } from 'quickrenard';

function Child() {
  const [updateChildData, data] = useStateMutation("childData.data");

  const handleUpdateData = () => {
    updateChildData("Updated Data from Child");
    console.log("Data updated!");
  };

  return (
    <div>
      <h3>Child Component</h3>
      <p>Data: {data}</p>
      <button onClick={handleUpdateData}>Update Data</button>
    </div>
  );
}
```

### Cousin Component:
This component queries the data and subscribes to its changes.

```javascript
// Cousin.js
import React from 'react';
import { useStateQuery, useStateSubscription } from 'quickrenard';

function Cousin() {
  const data = useStateQuery("childData.data");

  const handleDataChange = () => {
    console.log("Child data has changed!");
  };

  useStateSubscription("childData.data", handleDataChange);

  return (
    <div>
      <h3>Cousin Component</h3>
      <p>Data from Child: {data}</p>
    </div>
  );
}
```

With quickrenard, even if Child and Cousin aren't directly related, the state update in Child will trigger a subscription callback in Cousin, allowing seamless state sharing across different parts of your React application.

<br />
<hr />
<br />

# ğŸ¦Š QuickRenard ğŸ¦Š (Ver 2.0.0):  State & Function Management in React

QuickRenard provides a streamlined way to manage both state and functions globally in your React application. With the introduction of functionStore in version 2.0.0, QuickRenard not only allows you to manage state efficiently but also to register and invoke functions across your component tree, promoting reusability and separation of concerns.

## ğŸ¦Š Version 2.0.0 ğŸ¦Š: Introducing FunctionStore
<br />
Alongside state management, QuickRenard now brings a powerful functionStore utility, enabling you to:

- Register and manage globally accessible functions.
- Invoke registered functions from any component.
- Maintain cleaner code by abstracting common logic into functions.
- Avoid prop drilling for functions, just like state.

## Setup and Initialization

- To leverage the full capabilities of QuickRenard, follow these steps to set up your function stores:

<br />

### Initialize Function Store (New in v2.0.0):

```javascript
// functionStore.js
import { registerFunction, callFunction } from './functionStore';

// Register a global function
registerFunction('globalLogger', (message) => console.log(message));

// Later in your app, call the registered function
callFunction('globalLogger', 'This is a global log message');
```

## Using QuickRenard in Components

- QuickRenard provides hooks for querying, mutating state, and subscribing to state changes. Now with the function store, you can also register and call functions in your components.

1. Registering Functions (ğŸ¦ŠNew in v2.0.0):

```javascript
registerFunction('uniqueFunctionName', yourFunctionLogic);
```

2. Invoking Registered Functions (ğŸ¦ŠNew in v2.0.0):

```javascript
callFunction('uniqueFunctionName', ...args);
```

## ğŸ¦ŠExampleğŸ¦Š: Sharing State and Functions Between Distant Components

-With QuickRenard, components like Child and Cousin can share state and invoke functions without being directly related in the component tree.

### 0.Initialize Function Store

```javascript
// functionStore.js
const functionStore = {};

export const registerFunction = (name, fn) => {
  functionStore[name] = fn;
};

export const callFunction = (name, ...args) => {
  const fn = functionStore[name];
  if (fn) {
    return fn(...args);
  }
  throw new Error(`Function "${name}" is not registered.`);
};
```

### 1. Child Component:
This component mutates the data and registers a function.

```javascript
// Child.js
import React from 'react';
import { useStateMutation } from 'quickrenard';
import { registerFunction } from './functionStore'; // Import the registerFunction

function Child() {
  const [updateChildData, data] = useStateMutation("childData.data");

  const handleUpdateData = () => {
    updateChildData("Updated Data from Child");
    console.log("Data updated!");
  };  

  // Registering a new function called 'childFunction'
  const childFunction = (message) => {
    console.log("Message from Child Function:", message);
  };
  
  registerFunction('childFunction', childFunction);

  return (
    <div>
      <h3>Child Component</h3>
      <p>Data: {data}</p>
      <button onClick={handleUpdateData}>Update Data</button>
    </div>
  );
}

export default Child;
```

### 2. Cousin Component:
This component queries the data, subscribes to its changes, and invokes a function registered by the Child component.

```javascript
// Cousin.js
import React from 'react';
import { useStateQuery, useStateSubscription } from 'quickrenard';
import { callFunction } from './functionStore'; // Import the callFunction

function Cousin() {
  const data = useStateQuery("childData.data");

  const handleDataChange = () => {
    console.log("Child data has changed!");
    // Call the function registered in Child
    try {
      callFunction('childFunction', 'Data received by Cousin.');
    } catch (error) {
      console.error(error.message);
    }
  };

  useStateSubscription("childData.data", handleDataChange);

  return (
    <div>
      <h3>Cousin Component</h3>
      <p>Data from Child: {data}</p>
    </div>
  );
}

export default Cousin;
```

With the functionStore feature introduced in version 2.0.0, QuickRenard enhances its offering, making it a comprehensive solution for managing not just state but also functions across your React applications.

Remember to adjust your component examples to fit your exact implementation details. This documentation is meant to be a starting point that captures the essence of the functionStore functionality.